package com.example.demo.fromLeetcode;

// 20 ЗАДАЧА ИЗ СПИСКА BLIND CURATED 75
public class Solution_4 {

    public int climbStairs(int n) {

        // ВАРИАНТ С ИСПОЛЬЗОВАНИЕМ ПЕРЕМЕННЫХ ВМЕСТО МАССИВА - ЛОГИКА ТАКАЯ ЖЕ,
        // КАК И С МАССИВОМ - НО ПРИМЕНЕНИЕ ПЕРЕМЕННЫХ ВМЕСТО МАССИВА ЭКОНОМИТ ПАМЯТЬ
//        if (n == 1) {
//            return 1;
//        }
//
//        int prev1 = 1;
//        int prev2 = 2;
//
//        for (int i = 3; i <= n; i++) {
//            int current = prev1 + prev2;
//            prev1 = prev2;
//            prev2 = current;
//        }
//
//        return prev2;


        // ВАРИАНТ КОДА С ИСПОЛЬЗОВАНИЕМ МАССИВА

        // Если на лестнице 1 ступень, то число способов подняться по ней всегда равно 1
        if (n <= 1) {
            return 1;
        }

        // Массив для хранения числа способов. Его размер на 1 ячейку больше числа ступеней,
        // т.к. ячейку с индексом 0 не используем (это неудобно) - мы делаем так,
        // что ячейка с индексом 1 соответствует лестнице с 1 ступенью,
        // ячейка с индексом 2 - с 2 ступенями и т.д.
        // Поскольку ячейка с индексом 0 всегда пуста, то нужно, чтобы число ячеек в массиве
        // было на одну больше, чем число ступеней - чтобы была свободная ячейка для записи
        // результата подсчетов
        int[] ways = new int[n + 1];

        // Сразу кладем заранее известные нам результаты в ячейки:
        //      1) в ячейку с индексом 1 - число способов подняться по лестнице с 1 ступенью
        //      2) в ячейку с индексом 2 - число способов подняться по лестнице с 2 ступенями
        ways[1] = 1;
        ways[2] = 2;

        // В цикле вычисляем число способов в зависимости от числа ступеней:
        // подсчет начинаем с 3 ступени - складываем число способов подняться на предыдущую ступень
        // с числом способов подняться на предпредыдущую. Повторяем, пока не закончатся ступени -
        // и результат для последней ступени записываем в последниюю ячейку массива
        //
        for (int i = 3; i <= n; i++) {
            ways[i] = ways[i - 1] + ways[i - 2];
        }

        return ways[n];
    }
}
